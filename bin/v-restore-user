#!/bin/bash
# info: restore user
# options: USER BACKUP [WEB] [DNS] [MAIL] [DB] [CRON] [UDIR] [NOTIFY]
#
# The function for resotring user from backup.


#----------------------------------------------------------#
#                    Variable&Function                     #
#----------------------------------------------------------#

# Argument defenition
user=$1
backup=$2
web=$3
dns=$4
mail=$5
db=$6
cron=$7
udir=$8
notify=${9-no}

# Define backup dir
if [ -z "$BACKUP" ]; then
    BACKUP=/home/backup/
fi

# Includes
source $VESTA/conf/vesta.conf
source $VESTA/func/main.sh
source $VESTA/func/domain.sh
source $VESTA/func/ip.sh
source $VESTA/func/db.sh
source $VESTA/func/rebuild.sh

# Check backup function
is_backup_valid() {
    if [ ! -e "$BACKUP/$backup" ]; then
        echo "Error: backup not exist"
        log_event "$E_NOTEXIST" "$EVENT"
        exit $E_NOTEXIST
    fi
}


#----------------------------------------------------------#
#                    Verifications                         #
#----------------------------------------------------------#

args='USER BACKUP [WEB] [DNS] [MAIL] [DB] [CRON] [UDIR] [NOTIFY]'
check_args '2' "$#" $args
validate_format 'user' 'backup'
is_object_valid 'user' 'USER' "$user"
is_object_unsuspended 'user' 'USER' "$user"
is_backup_valid


#----------------------------------------------------------#
#                       Action                             #
#----------------------------------------------------------#

# Set notification email and subject
if [ "$notify" != 'no' ]; then
    subj="$user → restore failed"
    email=$(get_user_value '$CONTACT')
else
    subj="$user → restore failed"
    email=$(grep CONTACT $VESTA/data/users/admin/user.conf | cut -f 2 -d \')
fi
if [ -e "$VESTA/web/inc/mail-wrapper.php" ]; then
    send_mail="$VESTA/web/inc/mail-wrapper.php"
else
    send_mail=$(which mail)
fi

# Check disk usage
disk_usage=$(df $BACKUP |tail -n1 |tr ' ' '\n' |grep % |cut -f 1 -d %)
if [ "$disk_usage" -ge "$BACKUP_DISK_LIMIT" ]; then
    rm -rf $tmpdir
    echo "Not enough disk space to run backup" | $send_mail -s "$subj" $email
    echo "Error: Not enough disk space"
    sed -i "/ $user /d" $VESTA/data/queue/backup.pipe
    log_event "$E_DISK" "$EVENT"
    exit $E_DISK
fi

# Check load average
la=$(cat /proc/loadavg | cut -f 1 -d ' ' | cut -f 1 -d '.')
i=0
while [ "$la" -ge "$BACKUP_LA_LIMIT" ]; do
    echo "$(date "+%F %T") Load Average $la"
    echo
    sleep 60
    if [ "$i" -ge "15" ]; then
        echo "LoadAverage $i is above threshold" | $send_mail -s "$subj" $email
        echo "Error: LA is too high"
        sed -i "/ $user /d" $VESTA/data/queue/backup.pipe
        log_event "$E_LA" "$EVENT"
        exit $E_LA
    fi
    (( ++i))
done

# Creating temporary directory
tmpdir=$(mktemp -p $BACKUP -d)
if [ "$?" -ne 0 ]; then
    echo "Can't create tmp dir $tmpdir" | $send_mail -s "$subj" $email
    echo "Error: can't create tmp dir"
    log_event "$E_NOTEXIST" "$EVENT"
    exit $E_NOTEXIST
fi


# WEB
if [ "$web" != 'no' ]; then
    echo "-- WEB --"
    msg="$msg\n-- WEB --"

    # Create domain list
    domain_list=$(tar -tf $BACKUP/$backup | grep "^./web" |\
        grep domain_data.tar.gz | cut -f 3 -d '/')
    if [ ! -z "$web" ]; then
        dom_include_list=$(mktemp)
        for domain_include in ${web//,/ }; do
            echo "^$domain_include$" >> $dom_include_list
        done
        domain_list=$(echo "$domain_list" | egrep -f $dom_include_list )
        rm -f $dom_include_list
    fi

    for domain in $domain_list; do
        echo -e "$(date "+%F %T") $domain"
        msg="$msg\n$(date "+%F %T") $domain"

        # unpack domain container
        tar xf $BACKUP/$backup -C $tmpdir ./web/$domain
        if [ "$?" -ne 0 ]; then
            echo "Error: can't unpack $domain web contaner"
            echo "Can't unpack $domain web contaner" |\
                $send_mail -s "$subj" $email
            rm -rf $tmpdir
            exit $E_PARSING
        fi

        # Restore domain config
        check_config=$(grep "DOMAIN='$domain'" $USER_DATA/web.conf)
        if [ -z "$check_config" ]; then

            # Parse domain config
            eval $(cat $tmpdir/web/$domain/vesta/web.conf)

            # Check if domain new
            check_new=$(is_domain_new 'web' $domain)
            if [ ! -z "$check_new" ]; then
                echo "Error: web domain $domain belongs to another user"
                echo "Web domain $domain belongs to another user" |\
                    $sedn_mail -s "$subj" $email
                rm -rf $tmpdir
                log_event "$E_EXISTS" "$EVENT"
                exit $E_EXISTS
            fi

            # Check if domain alias is new
            for dom_alias in ${ALIAS//,/ }; do
                check_new=$(is_domain_new 'web' $dom_alias)
                if [ ! -z "$check_new" ]; then
                    # Delete conflicting alias
                    ALIAS=$(echo "$ALIAS" |\
                        sed -e "s/,/\n/g"|\
                        sed -e "s/^$dom_alias$//g"|\
                        sed -e "/^$/d"|\
                        sed -e ':a;N;$!ba;s/\n/,/g')
                fi
            done

            # Check ip address
            check_ip=$(is_ip_valid $IP)
            if [ -z "$check_ip" ]; then
                check_ip=$(is_ip_avalable $IP)
            fi
            if [ ! -z "$check_ip" ]; then
                IP=$(get_user_ip $user)
                if [ -z "$IP" ]; then
                    echo "Error: no avaiable IP address"
                    echo "No available IP address" |\
                        $send_mail -s "$subj" $email
                    log_event "$E_NOTEXIST" "$EVENT"
                    exit $E_NOTEXIST
                fi
                echo "$IP" > $tmpdir/ip_mapping.$domain
            fi

            # Check apache template
            check_tpl=$(is_apache_template_valid)
            if [ ! -z "$check_tpl" ]; then
                templates=$(ls -t $VESTA/data/templates/web/ |\
                    grep 'apache' |\
                    grep '\.tpl' |\
                    cut -f 2 -d '_' |\
                    cut -f 1 -d  '.')
                if [ ! -z "$(echo $templates |grep default)" ]; then
                    TPL=$(echo "$templates" |grep default |head -n1)
                else
                    TPL=$("$templates" |head -n1)
                fi

                if [ -z "$TPL" ]; then
                    echo "Error: no avaiable web template"
                    echo "No available web template" |\
                        $send_mail -s "$subj" $email
                    log_event "$E_NOTEXIST" "$EVENT"
                    exit $E_NOTEXIST
                fi
            fi

            # Check nginx template
            if [ ! -z "$NGINX" ]; then
                check_tpl=$(is_nginx_template_valid)
                if [ ! -z "$check_tpl" ]; then
                    templates=$(ls -t $VESTA/data/templates/web/ |\
                        grep 'nginx' |\
                        grep '\.tpl' |\
                        cut -f 2 -d '_' |\
                        cut -f 1 -d  '.')
                    if [ ! -z "$(echo $templates |grep default)" ]; then
                        NGINX=$(echo "$templates" |grep default |head -n1)
                    else
                        NGINX=$("$templates" |head -n1)
                    fi

                    if [ -z "$NGINX" ]; then
                        echo "Error: no avaiable nginx template"
                        echo "No available nginx tpl" |\
                            $send_mail -s "$subj" $email
                        log_event "$E_NOTEXIST" "$EVENT"
                        exit $E_NOTEXIST
                    fi
                fi
            fi

            str="DOMAIN='$domain' IP='$IP' IP6='$IP6' ALIAS='$ALIAS'"
            str="$str TPL='$TPL' SSL='$SSL' SSL_HOME='$SSL_HOME'"
            str="$str FTP_USER='$FTP_USER' FTP_MD5='$FTP_MD5' NGINX='$NGINX'"
            str="$str NGINX_EXT='$NGINX_EXT' STATS='$STATS'"
            str="$str STATS_USER='$STATS_USER' STATS_CRYPT='$STATS_CRYPT'"
            str="$str U_DISK='$U_DISK' U_BANDWIDTH='0' SUSPENDED='no'"
            str="$str TIME='$(date +%T)' DATE='$(date +%F)'"
            echo $str >> $USER_DATA/web.conf

            # Rebuild web config
            rebuild_web_domain_conf

            # Adding apache virtualhost
            httpd_conf='/etc/httpd/conf.d/vesta.conf'
            tmp_conf="$HOMEDIR/$user/conf/web/tmp_httpd.conf"
            conf="$HOMEDIR/$user/conf/web/httpd.conf"
            cat $tmp_conf >> $conf
            rm -f $tmp_conf
            httpd_include=$(grep "$conf" $httpd_conf )
            if [ -z "$httpd_include" ]; then
                echo "Include $conf" >> $httpd_conf
            fi

            # Adding ssl apache virtuualhost
            if [ "$ssl_change" = 'yes' ]; then
                tmp_conf="$HOMEDIR/$user/conf/web/tmp_shttpd.conf"
                conf="$HOMEDIR/$user/conf/web/shttpd.conf"
                cat $tmp_conf >> $conf
                rm -f $tmp_conf
            fi
            httpd_include=$(grep "$conf" $httpd_conf )
            if [ -z "$httpd_include" ]; then
                echo "Include $conf" >> $httpd_conf
            fi

            # Adding nginx virtualhost
            nginx_conf='/etc/nginx/conf.d/vesta_users.conf'
            if [ "$ngix_change" = 'yes' ]; then
                tmp_conf="$HOMEDIR/$user/conf/web/tmp_nginx.conf"
                conf="$HOMEDIR/$user/conf/web/nginx.conf"
                cat $tmp_conf >> $conf
                rm -f $tmp_conf
            fi
            nginx_include=$(grep "$conf" $nginx_conf )
            if [ -z "$nginx_include" ]; then
                echo "include $conf;" >> $nginx_conf
            fi

            # Adding ssl nginx virtualhost
            if [ "$ngix_change" = 'yes' ] && [ "$ssl_change" = 'yes' ]; then
                tmp_conf="$HOMEDIR/$user/conf/web/tmp_snginx.conf"
                conf="$HOMEDIR/$user/conf/web/snginx.conf"
                cat $tmp_conf >> $conf
                rm -f $tmp_conf
                nginx_include=$(grep "$conf" $nginx_conf )
                if [ -z "$nginx_include" ]; then
                    echo "include $conf;" >> $nginx_conf
                fi
            fi
        fi

        # Restore data
        tar -xzpf $tmpdir/web/$domain/domain_data.tar.gz \
            -C $HOMEDIR/$user/web/$domain/
        if [ "$?" -ne 0 ]; then
            echo "Error: can't unpack $domain data tarball"
            echo "Can't can't unpack $domain data tarball" |\
                $send_mail -s "$subj" $email
            rm -rf $tmpdir
            exit $E_PARSING
        fi
    done
    echo
    msg="$msg\n"
fi

# DNS
if [ "$dns" != 'no' ]; then
    echo "-- DNS --"
    msg="$msg\n-- DNS --"

    # Create domain list
    domain_list=$(tar -tf $BACKUP/$backup | grep "^./dns" |\
        grep dns.conf | cut -f 3 -d '/')
    if [ ! -z "$dns" ]; then
        dom_include_list=$(mktemp)
        for domain_include in ${dns//,/ }; do
            echo "^$domain_include$" >> $dom_include_list
        done
        domain_list=$(echo "$domain_list" | egrep -f $dom_include_list )
        rm -f $dom_include_list
    fi

    for domain in $domain_list; do
        echo -e "$(date "+%F %T") $domain"
        msg="$msg\n$(date "+%F %T") $domain"

        # unpack domain container
        tar xf $BACKUP/$backup -C $tmpdir ./dns/$domain
        if [ "$?" -ne 0 ]; then
            echo "Error: can't unpack $domain dns contaner"
            echo "Can't unpack $domain dns contaner" |\
                $send_mail -s "$subj" $email
            rm -rf $tmpdir
            exit $E_PARSING
        fi

        # Restore domain config
        check_config=$(grep "DOMAIN='$domain'" $USER_DATA/dns.conf)
        if [ -z "$check_config" ]; then

            # Parse domain config
            eval $(cat $tmpdir/dns/$domain/vesta/dns.conf)

            # Check if domain new
            check_new=$(is_domain_new 'dns' $domain)
            if [ ! -z "$check_new" ]; then
                echo "Error: dns domain $domain belongs to another user"
                echo "DNS domain $domain belongs to another user" |\
                    $send_mail -s "$subj" $email
                rm -rf $tmpdir
                log_event "$E_EXISTS" "$EVENT"
                exit $E_EXISTS
            fi

            # Check ip address
            if [ -e "$tmpdir/ip_mapping.$domain" ]; then
                OLD=$IP
                IP=$(cat $tmpdir/ip_mapping.$domain)
                sed -i "s/$OLD/$IP/g" $tmpdir/dns/$domain/vesta/$domain.conf
            else
                check_ip=$(is_ip_valid $IP)
                if [ ! -z "$check_ip" ]; then
                    if [ -z "$IP" ]; then
                        IP=$(get_user_ip $user)
                    fi
                fi
            fi
            if [ -z "$IP" ]; then
                echo "Error: no avaiable IP address"
                echo "No available IP address" | $send_mail -s "$subj" $email
                log_event "$E_NOTEXIST" "$EVENT"
                exit $E_NOTEXIST
            fi

            # Check dns template
            check_tpl=$(is_dns_template_valid)
            if [ ! -z "$check_tpl" ]; then
                templates=$(ls -t $VESTA/data/templates/dns/ |\
                    grep '\.tpl' |\
                    cut -f 1 -d  '.')
                if [ ! -z "$(echo $templates |grep default)" ]; then
                    TPL=$(echo "$templates" |grep default |head -n1)
                else
                    TPL=$("$templates" |head -n1)
                fi

                if [ -z "$TPL" ]; then
                    echo "Error: no avaiable dns template"
                    echo "No available dns template" |\
                        $send_mail -s "$subj" $email
                    log_event "$E_NOTEXIST" "$EVENT"
                    exit $E_NOTEXIST
                fi
            fi

            str="DOMAIN='$domain' IP='$IP' TPL='$TPL' TTL='$TTL' EXP='$EXP'"
            str="$str SOA='$SOA' RECORDS='$RECORDS' SUSPENDED='no'"
            str="$str TIME='$(date +%T)' DATE='$(date +%F)'"
            echo $str >> $USER_DATA/dns.conf
        fi

        # Restore dns records
        cp -f $tmpdir/dns/$domain/vesta/$domain.conf $USER_DATA/dns/

        # Rebuild dns config
        rebuild_dns_domain_conf
    done
    echo
    msg="$msg\n"
fi

# MAIL
if [ "$mail" != 'no' ]; then
    echo "-- MAIL --"
    msg="$msg\n-- MAIL --"

    # Create domain list
    domain_list=$(tar -tf $BACKUP/$backup | grep "^./mail" |\
        grep mail.conf | cut -f 3 -d '/')
    if [ ! -z "$mail" ]; then
        dom_include_list=$(mktemp)
        for domain_include in ${mail//,/ }; do
            echo "^$domain_include$" >> $dom_include_list
        done
        domain_list=$(echo "$domain_list" | egrep -f $dom_include_list )
        rm -f $dom_include_list
    fi

    for domain in $domain_list; do
        echo -e "$(date "+%F %T") $domain"
        msg="$msg\n$(date "+%F %T") $domain"

        # unpack domain container
        tar xf $BACKUP/$backup -C $tmpdir ./mail/$domain
        if [ "$?" -ne 0 ]; then
            echo "Error: can't unpack $domain mail contaner"
            echo "Can't can't unpack $domain mail contaner" |\
                $send_mail -s "$subj" $email
            rm -rf $tmpdir
            exit $E_PARSING
        fi

        # Restore domain config
        check_config=$(grep "DOMAIN='$domain'" $USER_DATA/mail.conf)
        if [ -z "$check_config" ]; then

            # Parse domain config
            eval $(cat $tmpdir/mail/$domain/vesta/mail.conf)

            # Check if domain new
            check_new=$(is_domain_new 'mail' $domain)
            if [ ! -z "$check_new" ]; then
                echo "Error: mail domain $domain belongs to another user"
                echo "Mail domain $domain belongs to another user" |\
                    $send_mail -s "$subj" $email
                rm -rf $tmpdir
                log_event "$E_EXISTS" "$EVENT"
                exit $E_EXISTS
            fi

            str="DOMAIN='$domain' ANTIVIRUS='$ANTIVIRUS' ANTISPAM='$ANTISPAM'"
            str="$str DKIM='$DKIM' ACCOUNTS='$ACCOUNTS' U_DISK='$U_DISK'"
            str="$str CATCHALL='$CATCHALL' SUSPENDED='no'"
            str="$str TIME='$(date +%T)' DATE='$(date +%F)'"
            echo $str >> $USER_DATA/mail.conf
        fi

        # Restore DKIM
        if [ -e "$tmpdir/mail/$domain/vesta/$domain.pem" ]; then
            cp -f $tmpdir/mail/$domain/vesta/$domain.pem $USER_DATA/mail/
            cp -f $tmpdir/mail/$domain/vesta/$domain.pub $USER_DATA/mail/
        fi

        # Restore email accounts
        cp -f $tmpdir/mail/$domain/vesta/$domain.conf $USER_DATA/mail/

        # Rebuild mail config
        rebuild_mail_domain_conf

        # Restore emails
        if [ -e "$tmpdir/mail/$domain/accounts.tar.gz" ]; then
            tar -xzpf $tmpdir/mail/$domain/accounts.tar.gz \
                -C $HOMEDIR/$user/mail/$domain/
            if [ "$?" -ne 0 ]; then
                echo "Error: can't unpack $domain mail account tarball"
                echo "Can't unpack $domain mail account tarball" |\
                    $send_mail -s "$subj" $email
                rm -rf $tmpdir
                exit $E_PARSING
            fi
        fi
    done
    echo
    msg="$msg\n"
fi

# DB
if [ "$db" != 'no' ]; then
    echo "-- DB --"
    msg="$msg\n-- DB --"

    # Create domain list
    db_list=$(tar -tf $BACKUP/$backup | grep "^./db" |\
        grep db.conf | cut -f 3 -d '/')
    if [ ! -z "$db" ]; then
        db_include_list=$(mktemp)
        for db_include in ${db//,/ }; do
            echo "^$db_include$" >> $db_include_list
        done
        db_list=$(echo "$db_list" | egrep -f $db_include_list )
        rm -f $db_include_list
    fi

    for db in $db_list; do
        echo -e "$(date "+%F %T") $db"
        msg="$msg\n$(date "+%F %T") $db"

        # unpack db container
        tar xf $BACKUP/$backup -C $tmpdir ./db/$db
        if [ "$?" -ne 0 ]; then
            echo "Error: can't unpack $db database contaner"
            echo "Can't unpack $db database contaner" |\
                $send_mail -s "$subj" $email
            rm -rf $tmpdir
            exit $E_PARSING
        fi

        # Restore domain config
        check_config=$(grep "DB='$db'" $USER_DATA/db.conf)
        if [ -z "$check_config" ]; then

            # Parse domain config
            eval $(cat $tmpdir/db/$db/vesta/db.conf)
            str="DB='$db' DBUSER='$DBUSER' MD5='$MD5' HOST='$HOST'"
            str="$str TYPE='$TYPE' CHARSET='$CHARSET' U_DISK='$U_DISK'"
            str="$str SUSPENDED='no' TIME='$(date +%T)' DATE='$(date +%F)'"
            echo $str >> $USER_DATA/db.conf
        fi

        # Unzip database dump
        gzip -d $tmpdir/db/$db/$db.*.sql.gz

        # Get database values
        get_database_values

        # Rebuild db
        case $TYPE in
            mysql) rebuild_mysql_database;
                    import_mysql_database $tmpdir/db/$db/$db.$TYPE.sql ;;
            pgsql) rebuild_pgsql_database;
                    import_pgsql_database $tmpdir/db/$db/$db.$TYPE.sql ;;
        esac
    done
    echo
    msg="$msg\n"
fi

# Cron
if [ "$cron" != 'no' ]; then
    echo "-- CRON --"
    msg="$msg\n-- CRON --"

    echo -e "$(date "+%F %T") $db"
    msg="$msg\n$(date "+%F %T") $db"

    # unpack cron container
    tar xf $BACKUP/$backup -C $tmpdir ./cron
    if [ "$?" -ne 0 ]; then
        echo "Error: can't unpack cron contaner"
        echo "Can't unpack cron contaner" | $send_mail -s "$subj" $email
        rm -rf $tmpdir
        exit $E_PARSING
    fi

    # Restore cron records
    cp $tmpdir/cron/cron.conf $USER_DATA/cron.conf

    # Rebuild cron
    sync_cron_jobs

    echo
    msg="$msg\n"
fi

# Restore user directories
if [ "$udir" != 'no' ]; then
    echo "-- USER DIR --"
    msg="$msg\n-- USER DIR --"

    # unpack user dir container
    if [ ! -z "$(tar -tf $BACKUP/$backup |grep './user_dir')" ]; then

        # Create user dir list
        udir_list=$(tar -tf $BACKUP/$backup | grep "^./user_dir" |\
            grep tar.gz | cut -f 3 -d '/' | sed -e "s/.tar.gz//")

        if [ ! -z "$udir" ]; then
            udir_include_list=$(mktemp)
            for udir_include in ${udir//,/ }; do
                echo "^$udir_include$" >> $udir_include_list
            done
            udir_list=$(echo "$udir_list" | egrep -f $udir_include_list )
            rm -f $udir_include_list
        fi

        for user_dir in $udir_list; do
            echo -e "$(date "+%F %T") $user_dir"
            msg="$msg\n$(date "+%F %T") $user_dir"

            # unpack user_dir container
            tar xf $BACKUP/$backup -C $tmpdir ./user_dir/$user_dir.tar.gz
            if [ "$?" -ne 0 ]; then
                echo "Error: can't unpack $user_dir user dir contaner"
                echo "Can't unpack $user_dir user dir contaner" |\
                    $send_mail -s "$subj" $email
                rm -rf $tmpdir
                exit $E_PARSING
            fi

            tar xzf $tmpdir/user_dir/$user_dir.tar.gz -C $HOMEDIR/$user
            if [ "$?" -ne 0 ]; then
                echo "Error: can't unpack $user_dir user dir contaner"
                echo "Can't unpack $user_dir user dir contaner" |\
                    $send_mail -s "$subj" $email
                rm -rf $tmpdir
                exit $E_PARSING
            fi
        done
    fi
    echo
    msg="$msg\n"
fi

# Remove temporary data
rm -rf $tmpdir

# Clean restore queue
sed -i "/v-restore-user $user /d" $VESTA/data/queue/backup.pipe

# Send notification
if [ "$notify" != 'no' ]; then
    subj="$user → restore has been completed"
    email=$(get_user_value '$CONTACT')
    echo -e "$msg" | $send_mail -s "$subj" $email
fi


#----------------------------------------------------------#
#                       Vesta                              #
#----------------------------------------------------------#

# Update user counters
$BIN/v-update-user-counters $user

# Logging
log_event "$OK" "$EVENT"

exit
